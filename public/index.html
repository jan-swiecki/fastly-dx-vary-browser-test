<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Fastly Vary in browser test</title>
	<meta name=viewport content="width=device-width, initial-scale=1, user-scalable=no">
	<link rel="preload" href="/test/preload" as="style">
	<link rel="preload" href="/test/preloadWithVaryAcceptEncoding" as="style">
	<link rel="preload" href="/test/preloadWithVaryMultiple" as="style">
	<link rel="stylesheet" href="/css/ux-platform.css">
	<style>
		body {
			margin: 20px;
		}
		h1 {
			margin-bottom: 20px;
		}
		tr.fail {
			background: #fff1b9;
		}
		tr.fail .expect,
		tr.fail .actual {
			font-weight: bold;
		}
	</style>
</head>
<body class='online'>
	<div class="layout">

	<h1>Vary granularity test</h1>

	<p>This test is designed to show that browsers do not store multiple copies of objects that have a <code>Vary</code> header on the response, one for each variation, as intermediate caches do.  When you serve a response through Fastly, we store each variation of the same URL as a separate cache entry, because different end users may want different variations (eg for language variants). However, a single user rarely changes their

	<table class='fui-table'>
		<thead>
			<tr><th>#</th><th>Request URL</th><th>Headers</th><th>Expected cache result</th><th>Actual result</th><th>Notes</th></tr>
		</thead>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/format</td>
			<td class='headers'>Accept: application/json</td>
			<td class='expect'>MISS</td>
			<td class='actual'></td>
			<td class='note'>May already be cached if the test page has been loaded recently</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/format</td>
			<td class='headers'>Accept: application/json</td>
			<td class='expect'>HIT</td>
			<td class='actual'></td>
			<td class='note'>Reloading the same object with same value in the Varied header should hit cache</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/format</td>
			<td class='headers'>Accept: text/csv</td>
			<td class='expect'>MISS</td>
			<td class='actual'></td>
			<td class='note'>Changing the value of the varied header should cause cache miss, and a different response.</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/format</td>
			<td class='headers'>Accept: application/json</td>
			<td class='expect'>HIT</td>
			<td class='actual'></td>
			<td class='note'>Changing back to the original varied header value would ideally hit the object cached earlier, but commonly browsers will use vary as a validator, rather than as part of the cache key, so the text/csv variant will potentially have overwritten the application/json version, in which case this will be a cache miss.</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/lang</td>
			<td class='headers'>Accept-Language: en</td>
			<td class='expect'>MISS</td>
			<td class='actual'></td>
			<td class='note'>May already be cached if the test page has been loaded recently</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/lang</td>
			<td class='headers'>Accept-Language: en</td>
			<td class='expect'>HIT</td>
			<td class='actual'></td>
			<td class='note'>Reloading the same object with same value in the Varied header should hit cache</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/lang</td>
			<td class='headers'>Accept-Language: jp</td>
			<td class='expect'>MISS</td>
			<td class='actual'></td>
			<td class='note'>Changing the value of the varied header should cause cache miss, and a different response.</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/lang</td>
			<td class='headers'>Accept-Language: en</td>
			<td class='expect'>HIT</td>
			<td class='actual'></td>
			<td class='note'>Changing back to the original varied header value would ideally hit the object cached earlier, but commonly browsers will use vary as a validator, rather than as part of the cache key, so the text/csv variant will potentially have overwritten the application/json version, in which case this will be a cache miss.</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/util/set-cookie?name=cacheVer&amp;val=1</td>
			<td class='headers'></td>
			<td class='expect'>MISS</td>
			<td class='actual'></td>
			<td class='note'>Sets a cookie to prepare for the next test</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/cookie</td>
			<td class='headers'></td>
			<td class='expect'>MISS</td>
			<td class='actual'></td>
			<td class='note'>A new response that varies on cookie will miss simply because this is the first time we've loaded this endpoint.   It should cache with a vary key set to the cookie value that has just been set.</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/cookie</td>
			<td class='headers'></td>
			<td class='expect'>HIT</td>
			<td class='actual'></td>
			<td class='note'>Reloading the same object with same value in the Varied header should hit cache</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/cookie2</td>
			<td class='headers'></td>
			<td class='expect'>MISS</td>
			<td class='actual'></td>
			<td class='note'>Different new endpoint also varying by cookie, should load from network, and cache against the same cookie value as the first cookie test.</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/cookie2</td>
			<td class='headers'></td>
			<td class='expect'>HIT</td>
			<td class='actual'></td>
			<td class='note'>Reloading the same object with same value in the Varied header should hit cache</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/util/set-cookie?name=cacheVer&amp;val=2</td>
			<td class='headers'></td>
			<td class='expect'>MISS</td>
			<td class='actual'></td>
			<td class='note'>Change the cookie value to prepare for the next test</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/cookie</td>
			<td class='headers'></td>
			<td class='expect'>MISS</td>
			<td class='actual'></td>
			<td class='note'>Re-requesting a previously requested endpoint but the request should now have a different cookie value, and since the stored cache entry is varying on cookie, this request will skip cache.</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/cookie2</td>
			<td class='headers'></td>
			<td class='expect'>MISS</td>
			<td class='actual'></td>
			<td class='note'>Same for another endpoint that varies by the same cookie.  Changing the one cookie value should affect all requests that vary on cookie.</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/preload</td>
			<td class='headers'></td>
			<td class='expect'>HIT</td>
			<td class='actual'></td>
			<td class='note'>An object that has been preloaded in the page's meta tags, should be in cache by the time it is requested as part of the test.</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/preloadWithVaryAcceptEncoding</td>
			<td class='headers'></td>
			<td class='expect'>HIT</td>
			<td class='actual'></td>
			<td class='note'>As above, but this time the preloaded object had a Vary header on the response.  Some browsers will ignore preload responses that have vary, so the request might be made even though the same resource was loaded earlier.</td>
		</tr>
		<tr class='test'>
			<td class='seqnum'></td>
			<td class='url'>/test/preloadWithVaryMultiple</td>
			<td class='headers'></td>
			<td class='expect'>HIT</td>
			<td class='actual'></td>
			<td class='note'>Now the preloaded object has a Vary header with multiple request headers listed.  Again this should be a cache hit because the object was preloaded.</td>
		</tr>
	</table>

	<h2>Conclusions</h2>

	<ul>
		<li>In terms of ability to instrument and understand what is going on, Chrome (58) and Firefox (54) both have support for the full ResourceTiming API, including reporting of <code>transferSize</code> which allows for easy and reliable understanding of whether a request hit cache.  Edge (15) does not support <code>transferSize</code> but we can make a reasonable approximation by using the timing metrics.  Safari (10) has no support for ResourceTiming at all, so we have to measure request timings manually.</li>
	</ul>

	</div>
	<script>
		let testNum = 0;
		const testRun = Array.from(document.querySelectorAll('.test')).reduce((out, testRow) => {
			testRow.querySelector('.seqnum').innerHTML = testNum++;
			return out.then(() => {
				const url = new URL(location.protocol + '//' + location.host + testRow.querySelector('.url').innerText);
				const headers = testRow
					.querySelector('.headers')
					.innerText
					.split(/\s*;\s*/)
					.reduce((heads, item) => {
						const [k,v] = item.split(/:\s*/, 2);
						if (k) heads[k] = v;
						return heads;
					}, {})
				;
				if ('clearResourceTimings' in performance) {
					performance.clearResourceTimings();
				}
				const startTime = performance.now();
				console.log(url);
				return fetch(url, {headers: headers, credentials: "same-origin"})
					.then(resp => {
						return resp.text();
					})
					.then(data => {
						const endTime = performance.now();
						let result = null;
						if ('getEntriesByName' in performance) {
							const perfentries = performance.getEntriesByName(url).filter(e => e instanceof PerformanceResourceTiming);
							if (perfentries.length) {
								const perf = perfentries.pop();
								if ('transferSize' in perf && perf.transferSize === 0) {
									result = 'HIT';
								} else if (Math.round(perf.responseStart - perf.requestStart) < 250) {
									result = 'HIT';
								} else {
									result = 'MISS';
								}
							}
						}
						if (!result) {
							if (Math.round(endTime - startTime) < 250) {
								result = 'HIT';
							} else {
								result = 'MISS';
							}
						}
						testRow.querySelector('.actual').innerHTML = result;
						if (result !== testRow.querySelector('.expect').innerText) {
							testRow.classList.add('fail');
						}
					})
				;
			});
		}, Promise.resolve())
		.catch(e => console.log(e));
	</script>
	</body>
</html>
